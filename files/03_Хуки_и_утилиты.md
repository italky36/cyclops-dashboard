# Задание 3: React-хуки и утилиты для сделок

## Контекст
Проект Cyclops Dashboard (Next.js 14). Типы, валидаторы и API routes уже созданы. Нужно реализовать React-хуки для работы со сделками на клиенте.

## Входные данные
- Типы: `types/cyclops/deals.ts`
- API routes: `app/api/deals/`
- Пример: `hooks/useCyclops.ts`, `hooks/useBeneficiaries.ts`

## Задача
Создать файл `hooks/useDeals.ts` с хуками для всех операций.

## Реализация

### Файл: `hooks/useDeals.ts`

```typescript
import { useState, useCallback, useEffect } from 'react';
import type {
  Deal,
  DealListItem,
  DealStatus,
  ListDealsParams,
  CreateDealParams,
  CreateDealResponse,
  ListDealsResponse,
  ComplianceCheckResult,
} from '@/types/cyclops/deals';

// ============================================
// Хук для списка сделок
// ============================================

interface UseDealsOptions {
  autoFetch?: boolean;
  initialParams?: ListDealsParams;
}

interface UseDealsReturn {
  deals: DealListItem[];
  loading: boolean;
  error: string | null;
  meta: { total: number; currentPage: number; perPage: number } | null;
  fetchDeals: (params?: ListDealsParams) => Promise<void>;
  refetch: () => Promise<void>;
}

export function useDeals(options: UseDealsOptions = {}): UseDealsReturn {
  const { autoFetch = true, initialParams } = options;
  
  const [deals, setDeals] = useState<DealListItem[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [meta, setMeta] = useState<UseDealsReturn['meta']>(null);
  const [lastParams, setLastParams] = useState<ListDealsParams | undefined>(initialParams);

  const fetchDeals = useCallback(async (params?: ListDealsParams) => {
    setLoading(true);
    setError(null);
    
    try {
      const queryParams = params || lastParams || {};
      setLastParams(queryParams);
      
      const query = new URLSearchParams();
      
      if (queryParams.page) query.set('page', String(queryParams.page));
      if (queryParams.per_page) query.set('per_page', String(queryParams.per_page));
      
      if (queryParams.filters) {
        const { status, ext_key, created_date_from, created_date_to, updated_at_from, updated_at_to } = queryParams.filters;
        if (status) query.set('status', status);
        if (ext_key) query.set('ext_key', ext_key);
        if (created_date_from) query.set('created_date_from', created_date_from);
        if (created_date_to) query.set('created_date_to', created_date_to);
        if (updated_at_from) query.set('updated_at_from', updated_at_from);
        if (updated_at_to) query.set('updated_at_to', updated_at_to);
      }

      const res = await fetch(`/api/deals?${query.toString()}`);
      const data: ListDealsResponse = await res.json();
      
      if (!res.ok) {
        throw new Error((data as any).error || 'Ошибка загрузки сделок');
      }
      
      setDeals(data.deals);
      setMeta({
        total: data.meta.total,
        currentPage: data.meta.page.current_page,
        perPage: data.meta.page.per_page,
      });
    } catch (e) {
      setError(e instanceof Error ? e.message : 'Неизвестная ошибка');
      setDeals([]);
    } finally {
      setLoading(false);
    }
  }, [lastParams]);

  const refetch = useCallback(() => fetchDeals(lastParams), [fetchDeals, lastParams]);

  useEffect(() => {
    if (autoFetch) {
      fetchDeals(initialParams);
    }
  }, []);

  return { deals, loading, error, meta, fetchDeals, refetch };
}

// ============================================
// Хук для одной сделки
// ============================================

interface UseDealReturn {
  deal: Deal | null;
  loading: boolean;
  error: string | null;
  fetchDeal: () => Promise<void>;
  executeDeal: (recipientNumbers?: number[]) => Promise<void>;
  rejectDeal: () => Promise<void>;
  cancelFromCorrection: () => Promise<void>;
  checkCompliance: () => Promise<ComplianceCheckResult[]>;
  updateDeal: (dealData: CreateDealParams) => Promise<void>;
}

export function useDeal(dealId: string): UseDealReturn {
  const [deal, setDeal] = useState<Deal | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchDeal = useCallback(async () => {
    if (!dealId) return;
    
    setLoading(true);
    setError(null);
    
    try {
      const res = await fetch(`/api/deals/${dealId}`);
      const data = await res.json();
      
      if (!res.ok) {
        throw new Error(data.error || 'Сделка не найдена');
      }
      
      setDeal(data.deal);
    } catch (e) {
      setError(e instanceof Error ? e.message : 'Ошибка загрузки');
      setDeal(null);
    } finally {
      setLoading(false);
    }
  }, [dealId]);

  // Исполнение сделки
  const executeDeal = useCallback(async (recipientNumbers?: number[]) => {
    setLoading(true);
    setError(null);
    
    try {
      const body = recipientNumbers 
        ? { recipients_execute: recipientNumbers.map(n => ({ number: n })) }
        : {};
      
      const res = await fetch(`/api/deals/${dealId}/execute`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      
      const data = await res.json();
      
      if (!res.ok) {
        throw new Error(data.error || 'Ошибка исполнения сделки');
      }
      
      // Обновляем данные сделки после исполнения
      await fetchDeal();
    } catch (e) {
      setError(e instanceof Error ? e.message : 'Ошибка');
      throw e;
    } finally {
      setLoading(false);
    }
  }, [dealId, fetchDeal]);

  // Отмена сделки (статус new)
  const rejectDeal = useCallback(async () => {
    setLoading(true);
    setError(null);
    
    try {
      const res = await fetch(`/api/deals/${dealId}`, {
        method: 'DELETE',
      });
      
      const data = await res.json();
      
      if (!res.ok) {
        throw new Error(data.error || 'Ошибка отмены сделки');
      }
      
      await fetchDeal();
    } catch (e) {
      setError(e instanceof Error ? e.message : 'Ошибка');
      throw e;
    } finally {
      setLoading(false);
    }
  }, [dealId, fetchDeal]);

  // Отмена из коррекции
  const cancelFromCorrection = useCallback(async () => {
    setLoading(true);
    setError(null);
    
    try {
      const res = await fetch(`/api/deals/${dealId}/cancel`, {
        method: 'POST',
      });
      
      const data = await res.json();
      
      if (!res.ok) {
        throw new Error(data.error || 'Ошибка отмены из коррекции');
      }
      
      await fetchDeal();
    } catch (e) {
      setError(e instanceof Error ? e.message : 'Ошибка');
      throw e;
    } finally {
      setLoading(false);
    }
  }, [dealId, fetchDeal]);

  // Проверка комплаенс
  const checkCompliance = useCallback(async (): Promise<ComplianceCheckResult[]> => {
    setLoading(true);
    setError(null);
    
    try {
      const res = await fetch(`/api/deals/${dealId}/compliance`, {
        method: 'POST',
      });
      
      const data = await res.json();
      
      if (!res.ok) {
        throw new Error(data.error || 'Ошибка проверки комплаенс');
      }
      
      return data.compliance_check_payments;
    } catch (e) {
      setError(e instanceof Error ? e.message : 'Ошибка');
      throw e;
    } finally {
      setLoading(false);
    }
  }, [dealId]);

  // Обновление сделки
  const updateDeal = useCallback(async (dealData: CreateDealParams) => {
    setLoading(true);
    setError(null);
    
    try {
      const res = await fetch(`/api/deals/${dealId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(dealData),
      });
      
      const data = await res.json();
      
      if (!res.ok) {
        throw new Error(data.error || 'Ошибка обновления сделки');
      }
      
      await fetchDeal();
    } catch (e) {
      setError(e instanceof Error ? e.message : 'Ошибка');
      throw e;
    } finally {
      setLoading(false);
    }
  }, [dealId, fetchDeal]);

  useEffect(() => {
    fetchDeal();
  }, [fetchDeal]);

  return {
    deal,
    loading,
    error,
    fetchDeal,
    executeDeal,
    rejectDeal,
    cancelFromCorrection,
    checkCompliance,
    updateDeal,
  };
}

// ============================================
// Хук для создания сделки
// ============================================

interface UseCreateDealReturn {
  createDeal: (params: CreateDealParams) => Promise<CreateDealResponse>;
  loading: boolean;
  error: string | null;
}

export function useCreateDeal(): UseCreateDealReturn {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const createDeal = useCallback(async (params: CreateDealParams): Promise<CreateDealResponse> => {
    setLoading(true);
    setError(null);
    
    try {
      const res = await fetch('/api/deals', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(params),
      });
      
      const data = await res.json();
      
      if (!res.ok) {
        throw new Error(data.error || 'Ошибка создания сделки');
      }
      
      return data as CreateDealResponse;
    } catch (e) {
      const message = e instanceof Error ? e.message : 'Ошибка';
      setError(message);
      throw e;
    } finally {
      setLoading(false);
    }
  }, []);

  return { createDeal, loading, error };
}
```

## Утилиты

### Файл: `lib/utils/deals.ts`

```typescript
import type { DealStatus, RecipientType } from '@/types/cyclops/deals';

// Человекочитаемые названия статусов
export const DEAL_STATUS_LABELS: Record<DealStatus, string> = {
  new: 'Новая',
  in_process: 'В процессе',
  partial: 'Частично исполнена',
  closed: 'Завершена',
  rejected: 'Отменена',
  correction: 'Требует коррекции',
  canceled_by_platform: 'Отменена площадкой',
};

// Цвета для статусов (Tailwind classes)
export const DEAL_STATUS_COLORS: Record<DealStatus, string> = {
  new: 'bg-gray-100 text-gray-800',
  in_process: 'bg-blue-100 text-blue-800',
  partial: 'bg-yellow-100 text-yellow-800',
  closed: 'bg-green-100 text-green-800',
  rejected: 'bg-red-100 text-red-800',
  correction: 'bg-orange-100 text-orange-800',
  canceled_by_platform: 'bg-red-100 text-red-800',
};

// Названия типов получателей
export const RECIPIENT_TYPE_LABELS: Record<RecipientType, string> = {
  payment_contract: 'Оплата по договору',
  commission: 'Комиссия',
  ndfl: 'НДФЛ (бюджетный платёж)',
  ndfl_to_virtual_account: 'Сбор на налоги (ВС)',
  payment_contract_by_sbp: 'СБП',
  payment_contract_by_sbp_v2: 'СБП (v2)',
  payment_contract_to_card: 'На карту',
};

// Доступные действия по статусу
export function getAvailableActions(status: DealStatus): {
  canExecute: boolean;
  canEdit: boolean;
  canReject: boolean;
  canCancelFromCorrection: boolean;
} {
  switch (status) {
    case 'new':
      return { canExecute: true, canEdit: true, canReject: true, canCancelFromCorrection: false };
    case 'partial':
      return { canExecute: true, canEdit: true, canReject: false, canCancelFromCorrection: false };
    case 'correction':
      return { canExecute: false, canEdit: true, canReject: false, canCancelFromCorrection: true };
    case 'in_process':
    case 'closed':
    case 'rejected':
    case 'canceled_by_platform':
    default:
      return { canExecute: false, canEdit: false, canReject: false, canCancelFromCorrection: false };
  }
}

// Форматирование суммы
export function formatAmount(amount: number): string {
  return new Intl.NumberFormat('ru-RU', {
    style: 'currency',
    currency: 'RUB',
    minimumFractionDigits: 2,
  }).format(amount);
}

// Форматирование даты
export function formatDate(dateString: string): string {
  return new Intl.DateTimeFormat('ru-RU', {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  }).format(new Date(dateString));
}

// Валидация суммы сделки
export function validateDealAmounts(
  totalAmount: number,
  payers: Array<{ amount: number }>,
  recipients: Array<{ amount: number }>
): { valid: boolean; error?: string } {
  const payersTotal = payers.reduce((sum, p) => sum + p.amount, 0);
  const recipientsTotal = recipients.reduce((sum, r) => sum + r.amount, 0);
  
  // Округляем до 2 знаков для сравнения
  const round = (n: number) => Math.round(n * 100) / 100;
  
  if (round(payersTotal) !== round(totalAmount)) {
    return { valid: false, error: `Сумма плательщиков (${payersTotal}) не равна общей сумме (${totalAmount})` };
  }
  
  if (round(recipientsTotal) !== round(totalAmount)) {
    return { valid: false, error: `Сумма получателей (${recipientsTotal}) не равна общей сумме (${totalAmount})` };
  }
  
  return { valid: true };
}

// Генерация уникального номера получателя
export function generateRecipientNumber(existingNumbers: number[]): number {
  if (existingNumbers.length === 0) return 1;
  return Math.max(...existingNumbers) + 1;
}
```

## Ожидаемый результат

Созданные файлы:
- `hooks/useDeals.ts` — хуки `useDeals`, `useDeal`, `useCreateDeal`
- `lib/utils/deals.ts` — утилиты для форматирования и валидации

## Примеры использования

```tsx
// Список сделок
function DealsPage() {
  const { deals, loading, error, meta, fetchDeals } = useDeals({
    initialParams: { per_page: 20, filters: { status: 'new' } }
  });
  
  // ...
}

// Детальная страница
function DealPage({ dealId }: { dealId: string }) {
  const { deal, loading, executeDeal, rejectDeal, checkCompliance } = useDeal(dealId);
  
  const handleExecute = async () => {
    await executeDeal();
    // Показать уведомление об успехе
  };
  
  // ...
}

// Создание сделки
function CreateDealPage() {
  const { createDeal, loading, error } = useCreateDeal();
  
  const handleSubmit = async (data: CreateDealParams) => {
    const result = await createDeal(data);
    // Проверить compliance_check_payments
    // Redirect на страницу сделки
  };
  
  // ...
}
```
